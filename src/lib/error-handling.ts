// „Éá„Éº„Çø„Éô„Éº„Çπ„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„ÅÆÂÆåÂÖ®ÂÆüË£Ö
import { User } from '@supabase/supabase-js'
import { supabase } from './supabase'

// „Ç®„É©„Éº„ÅÆÁ®ÆÈ°û„ÇíÂÆöÁæ©
export enum ErrorType {
  DATABASE_CONNECTION = 'database_connection',
  AUTHENTICATION = 'authentication',
  AUTHORIZATION = 'authorization',
  VALIDATION = 'validation',
  NETWORK = 'network',
  RATE_LIMIT = 'rate_limit',
  DATA_INTEGRITY = 'data_integrity',
  TRANSACTION = 'transaction',
  UNKNOWN = 'unknown'
}

// „Ç®„É©„Éº„ÅÆÈáçË¶ÅÂ∫¶„É¨„Éô„É´
export enum ErrorSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

// Áµ±‰∏Ä„Ç®„É©„Éº„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
export interface DatabaseError {
  type: ErrorType
  severity: ErrorSeverity
  message: string
  code?: string
  details?: any
  timestamp: Date
  user?: User | null
  context?: {
    operation: string
    table?: string
    data?: any
  }
  recoverable: boolean
  retryable: boolean
  userMessage: string
}

// Supabase„Ç®„É©„Éº„Çí„Ç´„Çπ„Çø„É†„Ç®„É©„Éº„Å´Â§âÊèõ
export function mapSupabaseError(
  error: any,
  context: {
    operation: string
    table?: string
    data?: any
  },
  user?: User | null
): DatabaseError {
  const timestamp = new Date()
  
  // Supabase„ÅÆ„Ç®„É©„Éº„Ç≥„Éº„Éâ„Å´Âü∫„Å•„ÅÑ„Å¶ÂàÜÈ°û
  let type = ErrorType.UNKNOWN
  let severity = ErrorSeverity.MEDIUM
  let recoverable = false
  let retryable = false
  let userMessage = '„Éá„Éº„Çø„Éô„Éº„Çπ„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü'

  if (!error) {
    return {
      type: ErrorType.UNKNOWN,
      severity: ErrorSeverity.LOW,
      message: 'Unknown error occurred',
      timestamp,
      user,
      context,
      recoverable: false,
      retryable: false,
      userMessage: '‰∏çÊòé„Å™„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü'
    }
  }

  const errorCode = error.code || error.status?.toString()
  const errorMessage = error.message || error.statusText || String(error)

  switch (errorCode) {
    // Êé•Á∂ö„Ç®„É©„Éº
    case 'ECONNREFUSED':
    case 'ENOTFOUND':
    case 'ETIMEDOUT':
      type = ErrorType.DATABASE_CONNECTION
      severity = ErrorSeverity.HIGH
      retryable = true
      userMessage = '„Éá„Éº„Çø„Éô„Éº„Çπ„Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì„ÄÇ„Åó„Å∞„Çâ„ÅèÂæå„Å´„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ'
      break

    // Ë™çË®º„Ç®„É©„Éº
    case '401':
    case 'PGRST301':
      type = ErrorType.AUTHENTICATION
      severity = ErrorSeverity.HIGH
      userMessage = '„É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å„Åß„Åô„ÄÇÂÜçÂ∫¶„É≠„Ç∞„Ç§„É≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'
      break

    // Ë™çÂèØ„Ç®„É©„Éº
    case '403':
    case 'PGRST302':
      type = ErrorType.AUTHORIZATION
      severity = ErrorSeverity.HIGH
      userMessage = '„Åì„ÅÆÊìç‰Ωú„ÇíÂÆüË°å„Åô„ÇãÊ®©Èôê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ'
      break

    // „Éê„É™„Éá„Éº„Ç∑„Éß„É≥„Ç®„É©„Éº
    case '400':
    case '422':
    case 'PGRST202':
      type = ErrorType.VALIDATION
      severity = ErrorSeverity.MEDIUM
      recoverable = true
      userMessage = 'ÂÖ•Âäõ„Éá„Éº„Çø„Å´‰∏çÂÇô„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÂÜÖÂÆπ„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'
      break

    // „É¨„Éº„ÉàÂà∂Èôê
    case '429':
      type = ErrorType.RATE_LIMIT
      severity = ErrorSeverity.MEDIUM
      retryable = true
      userMessage = '„É™„ÇØ„Ç®„Çπ„Éà„ÅåÂ§ö„Åô„Åé„Åæ„Åô„ÄÇ„Åó„Å∞„Çâ„ÅèÂæÖ„Å£„Å¶„Åã„Çâ„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ'
      break

    // „Éá„Éº„ÇøÊï¥ÂêàÊÄß„Ç®„É©„Éº
    case '23505': // unique violation
    case '23503': // foreign key violation
    case '23502': // not null violation
      type = ErrorType.DATA_INTEGRITY
      severity = ErrorSeverity.HIGH
      recoverable = true
      userMessage = '„Éá„Éº„Çø„ÅÆÊï¥ÂêàÊÄß„Å´ÂïèÈ°å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÁÆ°ÁêÜËÄÖ„Å´„ÅäÂïè„ÅÑÂêà„Çè„Åõ„Åè„Å†„Åï„ÅÑ„ÄÇ'
      break

    // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„Éº
    case 'NetworkError':
    case 'ERR_NETWORK':
      type = ErrorType.NETWORK
      severity = ErrorSeverity.HIGH
      retryable = true
      userMessage = '„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇÊé•Á∂ö„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'
      break

    // „Åù„ÅÆ‰ªñ„ÅÆHTTP„Ç®„É©„Éº
    case '500':
    case '502':
    case '503':
    case '504':
      type = ErrorType.DATABASE_CONNECTION
      severity = ErrorSeverity.CRITICAL
      retryable = true
      userMessage = '„Çµ„Éº„Éê„Éº„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Åó„Å∞„Çâ„ÅèÂæå„Å´„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ'
      break

    default:
      // ÁâπÂÆö„ÅÆ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅßÂà§ÂÆö
      if (errorMessage.includes('duplicate key') || errorMessage.includes('already exists')) {
        type = ErrorType.DATA_INTEGRITY
        severity = ErrorSeverity.MEDIUM
        recoverable = true
        userMessage = '„Éá„Éº„Çø„ÅåÈáçË§á„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ'
      } else if (errorMessage.includes('not found') || errorMessage.includes('does not exist')) {
        type = ErrorType.VALIDATION
        severity = ErrorSeverity.MEDIUM
        recoverable = true
        userMessage = 'ÊåáÂÆö„Åï„Çå„Åü„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ'
      } else if (errorMessage.includes('connection') || errorMessage.includes('timeout')) {
        type = ErrorType.DATABASE_CONNECTION
        severity = ErrorSeverity.HIGH
        retryable = true
        userMessage = '„Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂ö„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ'
      }
      break
  }

  return {
    type,
    severity,
    message: errorMessage,
    code: errorCode,
    details: error,
    timestamp,
    user,
    context,
    recoverable,
    retryable,
    userMessage
  }
}

// „Ç®„É©„Éº„É≠„Ç∞„ÅÆË®òÈå≤
export class ErrorLogger {
  private static instance: ErrorLogger
  private errorLog: DatabaseError[] = []
  private maxLogSize = 1000
  
  static getInstance(): ErrorLogger {
    if (!ErrorLogger.instance) {
      ErrorLogger.instance = new ErrorLogger()
    }
    return ErrorLogger.instance
  }

  logError(error: DatabaseError): void {
    this.errorLog.unshift(error)
    
    // „É≠„Ç∞„Çµ„Ç§„Ç∫Âà∂Èôê
    if (this.errorLog.length > this.maxLogSize) {
      this.errorLog = this.errorLog.slice(0, this.maxLogSize)
    }

    // „Ç≥„É≥„ÇΩ„Éº„É´„Å´Âá∫Âäõ
    const logLevel = this.getLogLevel(error.severity)
    console[logLevel](`[${error.type}] ${error.message}`, {
      context: error.context,
      timestamp: error.timestamp,
      user: error.user?.id,
      details: error.details
    })

    // „ÇØ„É™„ÉÜ„Ç£„Ç´„É´„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÅØËøΩÂä†Âá¶ÁêÜ
    if (error.severity === ErrorSeverity.CRITICAL) {
      this.handleCriticalError(error)
    }

    // „É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠òÔºàÊúÄÊñ∞100‰ª∂„ÅÆ„ÅøÔºâ
    try {
      const recentErrors = this.errorLog.slice(0, 100).map(e => ({
        ...e,
        details: undefined // Ë©≥Á¥∞ÊÉÖÂ†±„ÅØÈô§Â§ñ„Åó„Å¶„Çµ„Ç§„Ç∫„ÇíÂâäÊ∏õ
      }))
      localStorage.setItem('tokiwa-error-log', JSON.stringify(recentErrors))
    } catch (e) {
      console.warn('„Ç®„É©„Éº„É≠„Ç∞„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó:', e)
    }
  }

  private getLogLevel(severity: ErrorSeverity): 'log' | 'warn' | 'error' {
    switch (severity) {
      case ErrorSeverity.LOW:
        return 'log'
      case ErrorSeverity.MEDIUM:
        return 'warn'
      case ErrorSeverity.HIGH:
      case ErrorSeverity.CRITICAL:
        return 'error'
      default:
        return 'log'
    }
  }

  private handleCriticalError(error: DatabaseError): void {
    // „ÇØ„É™„ÉÜ„Ç£„Ç´„É´„Ç®„É©„Éº„ÅÆËøΩÂä†Âá¶ÁêÜ
    console.error('üö® CRITICAL ERROR DETECTED üö®', error)
    
    // ÂèØËÉΩ„Åß„ÅÇ„Çå„Å∞„É¶„Éº„Ç∂„Éº„Å´Á∑äÊÄ•ÈÄöÁü•
    if (typeof window !== 'undefined') {
      const message = `ÈáçÂ§ß„Å™„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÇíÂÜçËµ∑Âãï„Åô„Çã„Åì„Å®„ÇíÊé®Â•®„Åó„Åæ„Åô„ÄÇ\n\n„Ç®„É©„Éº: ${error.userMessage}`
      
      // ÈùûÂêåÊúü„ÅßÈÄöÁü•„ÇíË°®Á§∫
      setTimeout(() => {
        if (confirm(message + '\n\n„Éö„Éº„Ç∏„ÇíÂÜçË™≠„ÅøËæº„Åø„Åó„Åæ„Åô„ÅãÔºü')) {
          window.location.reload()
        }
      }, 1000)
    }
  }

  getRecentErrors(limit: number = 50): DatabaseError[] {
    return this.errorLog.slice(0, limit)
  }

  getErrorsByType(type: ErrorType): DatabaseError[] {
    return this.errorLog.filter(error => error.type === type)
  }

  getErrorsBySeverity(severity: ErrorSeverity): DatabaseError[] {
    return this.errorLog.filter(error => error.severity === severity)
  }

  clearErrorLog(): void {
    this.errorLog = []
    localStorage.removeItem('tokiwa-error-log')
  }

  getErrorStats(): {
    total: number
    byType: Record<ErrorType, number>
    bySeverity: Record<ErrorSeverity, number>
  } {
    const stats = {
      total: this.errorLog.length,
      byType: {} as Record<ErrorType, number>,
      bySeverity: {} as Record<ErrorSeverity, number>
    }

    // ÂàùÊúüÂåñ
    Object.values(ErrorType).forEach(type => {
      stats.byType[type] = 0
    })
    Object.values(ErrorSeverity).forEach(severity => {
      stats.bySeverity[severity] = 0
    })

    // „Ç´„Ç¶„É≥„Éà
    this.errorLog.forEach(error => {
      stats.byType[error.type] = (stats.byType[error.type] || 0) + 1
      stats.bySeverity[error.severity] = (stats.bySeverity[error.severity] || 0) + 1
    })

    return stats
  }
}

// „É™„Éà„É©„Ç§Ê©üËÉΩ‰ªò„Åç„Éá„Éº„Çø„Éô„Éº„ÇπÊìç‰Ωú„É©„ÉÉ„Éë„Éº
export async function executeWithRetry<T>(
  operation: () => Promise<T>,
  context: {
    operation: string
    table?: string
    data?: any
  },
  user?: User | null,
  maxRetries: number = 3,
  backoffMs: number = 1000
): Promise<{ data: T | null; error: DatabaseError | null }> {
  let lastError: DatabaseError | null = null
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const result = await operation()
      return { data: result, error: null }
      
    } catch (error) {
      const dbError = mapSupabaseError(error, context, user)
      lastError = dbError
      
      // „Ç®„É©„Éº„É≠„Ç∞„Å´Ë®òÈå≤
      ErrorLogger.getInstance().logError(dbError)
      
      // „É™„Éà„É©„Ç§ÂèØËÉΩ„Åß„Å™„ÅÑÂ†¥Âêà„ÅØÂç≥Â∫ß„Å´ÁµÇ‰∫Ü
      if (!dbError.retryable || attempt === maxRetries) {
        break
      }
      
      // ÊåáÊï∞„Éê„ÉÉ„ÇØ„Ç™„Éï„ÅßÂæÖÊ©ü
      const waitTime = backoffMs * Math.pow(2, attempt)
      console.log(`„É™„Éà„É©„Ç§ ${attempt + 1}/${maxRetries} in ${waitTime}ms...`)
      await new Promise(resolve => setTimeout(resolve, waitTime))
    }
  }
  
  return { data: null, error: lastError }
}

// „Ç®„É©„ÉºÂõûÂæ©Âá¶ÁêÜ
export class ErrorRecovery {
  static async attemptRecovery(error: DatabaseError): Promise<boolean> {
    if (!error.recoverable) {
      return false
    }

    try {
      switch (error.type) {
        case ErrorType.AUTHENTICATION:
          return await this.recoverAuthentication()
          
        case ErrorType.DATABASE_CONNECTION:
          return await this.recoverConnection()
          
        case ErrorType.DATA_INTEGRITY:
          return await this.recoverDataIntegrity(error)
          
        default:
          return false
      }
    } catch (e) {
      console.error('„Ç®„É©„ÉºÂõûÂæ©Âá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº:', e)
      return false
    }
  }

  private static async recoverAuthentication(): Promise<boolean> {
    try {
      // supabase„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅÆÂ≠òÂú®Á¢∫Ë™ç
      if (!supabase) {
        return false
      }
      
      // „Çª„ÉÉ„Ç∑„Éß„É≥Êõ¥Êñ∞„ÇíË©¶Ë°å
      const { data: { session }, error } = await supabase.auth.getSession()
      if (error || !session) {
        // „É≠„Ç∞„Ç§„É≥„Éö„Éº„Ç∏„Å´„É™„ÉÄ„Ç§„É¨„ÇØ„Éà
        if (typeof window !== 'undefined') {
          window.location.href = '/auth/login'
        }
        return false
      }
      return true
    } catch (e) {
      return false
    }
  }

  private static async recoverConnection(): Promise<boolean> {
    // Á∞°Âçò„Å™Êé•Á∂ö„ÉÜ„Çπ„Éà
    try {
      if (!supabase) {
        return false
      }
      const { error } = await supabase.from('profiles').select('id').limit(1)
      return !error
    } catch (e) {
      return false
    }
  }

  private static async recoverDataIntegrity(error: DatabaseError): Promise<boolean> {
    // „Éá„Éº„ÇøÊï¥ÂêàÊÄß„Ç®„É©„Éº„ÅÆËá™Âãï‰øÆÂæ©„ÅØÂç±Èô∫„Å™„ÅÆ„Åß„ÄÅÂü∫Êú¨ÁöÑ„Å´false„ÇíËøî„Åô
    // ÁâπÂÆö„ÅÆÂÆâÂÖ®„Å™„Ç±„Éº„Çπ„ÅÆ„ÅøÂÆüË£Ö„Åô„Çã
    console.warn('„Éá„Éº„ÇøÊï¥ÂêàÊÄß„Ç®„É©„Éº„ÅØÊâãÂãï„Åß„ÅÆÂØæÂøú„ÅåÂøÖË¶Å„Åß„Åô:', error.message)
    return false
  }
}

// „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„ÅÆ„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£Èñ¢Êï∞
export function createErrorHandler(
  context: {
    operation: string
    table?: string
  },
  user?: User | null
) {
  return (error: any) => {
    const dbError = mapSupabaseError(error, context, user)
    ErrorLogger.getInstance().logError(dbError)
    return dbError
  }
}

// „Éï„É≠„É≥„Éà„Ç®„É≥„ÉâÁî®„ÅÆÁµ±‰∏Ä„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Éï„ÉÉ„ÇØÔºàReactÔºâ
export function useErrorHandler() {
  const handleError = (
    error: any,
    context: {
      operation: string
      table?: string
      data?: any
    },
    user?: User | null
  ): DatabaseError => {
    const dbError = mapSupabaseError(error, context, user)
    ErrorLogger.getInstance().logError(dbError)
    
    // ÂøÖË¶Å„Å´Âøú„Åò„Å¶ÂõûÂæ©Âá¶ÁêÜ„ÇíË©¶Ë°å
    if (dbError.recoverable) {
      ErrorRecovery.attemptRecovery(dbError)
    }
    
    return dbError
  }

  const executeWithErrorHandling = async <T>(
    operation: () => Promise<T>,
    context: {
      operation: string
      table?: string
      data?: any
    },
    user?: User | null
  ): Promise<{ data: T | null; error: DatabaseError | null }> => {
    return await executeWithRetry(operation, context, user)
  }

  return {
    handleError,
    executeWithErrorHandling,
    getErrorLog: () => ErrorLogger.getInstance().getRecentErrors(),
    getErrorStats: () => ErrorLogger.getInstance().getErrorStats(),
    clearErrorLog: () => ErrorLogger.getInstance().clearErrorLog()
  }
}