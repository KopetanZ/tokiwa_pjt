# フロントエンド設計仕様書
**トキワシティ訓練所 - 初代ポケモンリスペクト UI**

---

## 1. フロントエンド概要

### 1.1 技術スタック
- **Framework**: Next.js 14 (App Router)
- **UI Library**: shadcn/ui + カスタムレトロコンポーネント
- **Styling**: Tailwind CSS + CSS Modules (ドット絵対応)
- **State Management**: Zustand + React Query
- **Animation**: Framer Motion + CSS Animations
- **Icons**: Pixel Art Icons + Lucide Icons
- **Real-time**: Supabase Realtime + Server-Sent Events
- **Image Processing**: Next.js Image + Sharp

### 1.2 デザインテーマ：初代ポケモンリスペクト

#### カラーパレット（Game Boy風）
```css
:root {
  /* Game Boy Original (4色) */
  --gb-dark-green: #0F380F;
  --gb-mid-green: #306230;
  --gb-light-green: #8BAC0F;
  --gb-lightest-green: #9BBD0F;
  
  /* Game Boy Color (拡張パレット) */
  --gbc-red: #C84448;
  --gbc-blue: #4488CC;
  --gbc-yellow: #F4D444;
  --gbc-orange: #F4A444;
  
  /* UI拡張色 */
  --retro-text: #0F380F;
  --retro-bg: #9BBD0F;
  --retro-border: #306230;
  --retro-accent: #C84448;
  
  /* アニメーション */
  --pixel-animation-speed: 0.5s;
  --text-scroll-speed: 2s;
}
```

#### フォント設定
```css
/* レトロフォント */
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

.font-pixel {
  font-family: 'Press Start 2P', monospace;
  font-size: 8px;
  line-height: 1.4;
  letter-spacing: 0.05em;
}

.font-pixel-large {
  font-family: 'Press Start 2P', monospace;
  font-size: 12px;
  line-height: 1.2;
}
```

---

## 2. ページ構成・ルーティング

### 2.1 App Router構成
```
app/
├── layout.tsx              # ルートレイアウト（レトロUI共通要素）
├── page.tsx               # ダッシュボード（スクール概要）
├── globals.css            # レトロスタイル定義
├── components/            # 共通コンポーネント
├── (dashboard)/           # ダッシュボードグループ
│   ├── layout.tsx         # ダッシュボードレイアウト
│   ├── trainers/          # トレーナー管理
│   │   ├── page.tsx       # トレーナー一覧
│   │   ├── [id]/          # 個別トレーナー
│   │   │   ├── page.tsx   # トレーナー詳細
│   │   │   └── edit/      # トレーナー編集
│   │   └── hire/          # 新規雇用
│   ├── expeditions/       # 派遣管理
│   │   ├── page.tsx       # 派遣一覧・管理
│   │   ├── [id]/          # 個別派遣詳細
│   │   ├── locations/     # 派遣先一覧
│   │   └── active/        # 進行中派遣
│   ├── pokemon/           # ポケモン管理
│   │   ├── page.tsx       # ポケモン一覧
│   │   ├── [id]/          # 個別ポケモン
│   │   ├── dex/           # 図鑑
│   │   └── party/         # パーティ編成
│   ├── facilities/        # 施設管理
│   │   ├── page.tsx       # 施設一覧
│   │   ├── [id]/          # 個別施設
│   │   └── upgrade/       # アップグレード
│   ├── economy/           # 経済管理
│   │   ├── page.tsx       # 収支サマリー
│   │   ├── transactions/  # 取引履歴
│   │   └── reports/       # レポート
│   └── events/            # イベント・大会
├── interventions/         # リアルタイム介入（モーダル）
├── settings/              # 設定
└── loading.tsx            # ローディング画面（ドット絵アニメーション）
```

### 2.2 レイアウト設計

#### メインレイアウト（初代ポケモン風）
```typescript
// app/layout.tsx
interface RootLayoutProps {
  children: React.ReactNode;
}

export default function RootLayout({ children }: RootLayoutProps) {
  return (
    <html lang="ja">
      <body className="font-pixel bg-retro-bg text-retro-text">
        <RetroGameBoy>
          <Header />
          <NavigationMenu />
          <main className="pixel-container">
            {children}
          </main>
          <Footer />
          <InterventionManager />
          <NotificationSystem />
        </RetroGameBoy>
      </body>
    </html>
  );
}
```

#### Game Boy風UIコンテナ
```tsx
// components/layout/RetroGameBoy.tsx
interface RetroGameBoyProps {
  children: React.ReactNode;
}

export const RetroGameBoy: React.FC<RetroGameBoyProps> = ({ children }) => {
  return (
    <div className="gameboy-container">
      {/* Game Boy外装 */}
      <div className="gameboy-shell">
        {/* スクリーン部分 */}
        <div className="gameboy-screen">
          <div className="pixel-grid">
            {children}
          </div>
        </div>
        
        {/* コントロールパッド（装飾） */}
        <div className="gameboy-controls">
          <div className="d-pad"></div>
          <div className="action-buttons">
            <button className="btn-a">A</button>
            <button className="btn-b">B</button>
          </div>
        </div>
      </div>
    </div>
  );
};
```

---

## 3. コンポーネント設計

### 3.1 レトロUI基本コンポーネント

#### PixelButton（ドット絵風ボタン）
```tsx
// components/ui/PixelButton.tsx
interface PixelButtonProps {
  variant: 'primary' | 'secondary' | 'danger' | 'success';
  size: 'sm' | 'md' | 'lg';
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
  loading?: boolean;
}

export const PixelButton: React.FC<PixelButtonProps> = ({
  variant,
  size,
  children,
  onClick,
  disabled,
  loading
}) => {
  return (
    <button
      className={`
        pixel-button
        pixel-button--${variant}
        pixel-button--${size}
        ${disabled ? 'pixel-button--disabled' : ''}
        ${loading ? 'pixel-button--loading' : ''}
      `}
      onClick={onClick}
      disabled={disabled}
    >
      {loading && <PixelSpinner />}
      <span className="pixel-button__text">{children}</span>
    </button>
  );
};

/* CSS */
.pixel-button {
  @apply font-pixel border-2 border-retro-border bg-retro-bg;
  image-rendering: pixelated;
  transition: all 0.1s ease-in-out;
  
  /* ドット絵風の3D効果 */
  box-shadow: 
    2px 2px 0px var(--retro-border),
    4px 4px 0px rgba(15, 56, 15, 0.3);
}

.pixel-button:hover {
  transform: translate(-1px, -1px);
  box-shadow: 
    3px 3px 0px var(--retro-border),
    5px 5px 0px rgba(15, 56, 15, 0.3);
}

.pixel-button:active {
  transform: translate(1px, 1px);
  box-shadow: 
    1px 1px 0px var(--retro-border),
    2px 2px 0px rgba(15, 56, 15, 0.3);
}
```

#### PixelDialog（メッセージボックス）
```tsx
// components/ui/PixelDialog.tsx
interface PixelDialogProps {
  open: boolean;
  onClose: () => void;
  title?: string;
  children: React.ReactNode;
  showCloseButton?: boolean;
}

export const PixelDialog: React.FC<PixelDialogProps> = ({
  open,
  onClose,
  title,
  children,
  showCloseButton = true
}) => {
  if (!open) return null;

  return (
    <div className="pixel-dialog-overlay">
      <div className="pixel-dialog">
        {/* 初代ポケモン風のタイトルバー */}
        {title && (
          <div className="pixel-dialog-header">
            <h3 className="font-pixel-large">{title}</h3>
            {showCloseButton && (
              <button className="pixel-close-btn" onClick={onClose}>
                ×
              </button>
            )}
          </div>
        )}
        
        {/* メッセージ内容 */}
        <div className="pixel-dialog-content">
          {children}
        </div>
      </div>
    </div>
  );
};

/* CSS */
.pixel-dialog {
  @apply bg-retro-bg border-4 border-retro-border;
  max-width: 400px;
  min-height: 200px;
  image-rendering: pixelated;
  
  /* 初代ポケモンのメッセージボックス風 */
  border-image: 
    url('/images/ui/dialog-border.png') 8 repeat;
}
```

#### PixelProgressBar
```tsx
// components/ui/PixelProgressBar.tsx
interface PixelProgressBarProps {
  value: number; // 0-100
  max?: number;
  color: 'hp' | 'exp' | 'progress' | 'danger';
  showLabel?: boolean;
  animated?: boolean;
}

export const PixelProgressBar: React.FC<PixelProgressBarProps> = ({
  value,
  max = 100,
  color,
  showLabel,
  animated
}) => {
  const percentage = Math.min((value / max) * 100, 100);
  
  return (
    <div className="pixel-progress-container">
      {showLabel && (
        <div className="pixel-progress-label font-pixel">
          {value}/{max}
        </div>
      )}
      
      <div className="pixel-progress-bar">
        <div 
          className={`
            pixel-progress-fill 
            pixel-progress-fill--${color}
            ${animated ? 'pixel-progress-fill--animated' : ''}
          `}
          style={{ width: `${percentage}%` }}
        />
      </div>
    </div>
  );
};

/* CSS - ポケモンのHPバー風 */
.pixel-progress-bar {
  @apply h-2 bg-gray-300 border border-retro-border;
  image-rendering: pixelated;
}

.pixel-progress-fill--hp {
  background: linear-gradient(90deg, #44CC44 0%, #88FF88 100%);
}

.pixel-progress-fill--exp {
  background: linear-gradient(90deg, #4488CC 0%, #88CCFF 100%);
}

.pixel-progress-fill--animated {
  animation: pixelGlow 1s ease-in-out infinite alternate;
}

@keyframes pixelGlow {
  from { filter: brightness(1); }
  to { filter: brightness(1.2); }
}
```

### 3.2 ゲーム固有コンポーネント

#### PokemonSprite（ポケモンドット絵表示）
```tsx
// components/pokemon/PokemonSprite.tsx
interface PokemonSpriteProps {
  speciesId: number;
  variant: 'front' | 'back' | 'icon' | 'retro';
  size: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
  animated?: boolean;
  shiny?: boolean;
  onClick?: () => void;
}

export const PokemonSprite: React.FC<PokemonSpriteProps> = ({
  speciesId,
  variant,
  size,
  animated,
  shiny,
  onClick
}) => {
  const { data: spriteData, isLoading } = usePokemonSprite(speciesId, variant);
  
  return (
    <div 
      className={`
        pokemon-sprite 
        pokemon-sprite--${size}
        ${animated ? 'pokemon-sprite--animated' : ''}
        ${shiny ? 'pokemon-sprite--shiny' : ''}
        ${onClick ? 'pokemon-sprite--clickable' : ''}
      `}
      onClick={onClick}
    >
      {isLoading ? (
        <PixelSpinner />
      ) : (
        <Image
          src={spriteData?.url || '/images/pokemon/unknown.png'}
          alt={spriteData?.name || 'Unknown Pokemon'}
          width={spriteData?.width || 64}
          height={spriteData?.height || 64}
          style={{ imageRendering: 'pixelated' }}
        />
      )}
      
      {animated && <PixelAnimationEffect />}
      {shiny && <ShinySparkleEffect />}
    </div>
  );
};

/* CSS */
.pokemon-sprite {
  @apply inline-block relative;
  image-rendering: pixelated;
  image-rendering: -moz-crisp-edges;
  image-rendering: crisp-edges;
}

.pokemon-sprite--animated {
  animation: pokemonBounce 2s ease-in-out infinite;
}

@keyframes pokemonBounce {
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-4px); }
}

.pokemon-sprite--shiny::after {
  content: '✨';
  position: absolute;
  top: -4px;
  right: -4px;
  font-size: 12px;
  animation: sparkle 1s ease-in-out infinite;
}
```

#### TrainerCard（トレーナーカード）
```tsx
// components/trainers/TrainerCard.tsx
interface TrainerCardProps {
  trainer: TrainerSummary;
  onClick?: () => void;
  showStatus?: boolean;
  showParty?: boolean;
}

export const TrainerCard: React.FC<TrainerCardProps> = ({
  trainer,
  onClick,
  showStatus,
  showParty
}) => {
  return (
    <div 
      className={`
        trainer-card
        ${onClick ? 'trainer-card--clickable' : ''}
        ${trainer.status === 'on_expedition' ? 'trainer-card--busy' : ''}
      `}
      onClick={onClick}
    >
      {/* トレーナースプライト */}
      <div className="trainer-card__sprite">
        <Image
          src={trainer.spritePath}
          alt={trainer.name}
          width={48}
          height={48}
          style={{ imageRendering: 'pixelated' }}
        />
      </div>
      
      {/* トレーナー情報 */}
      <div className="trainer-card__info">
        <h3 className="font-pixel">{trainer.name}</h3>
        <p className="font-pixel text-xs">
          {trainer.job.nameJa} Lv.{trainer.job.level}
        </p>
        
        {showStatus && (
          <StatusBadge status={trainer.status} />
        )}
        
        {showParty && (
          <div className="trainer-card__party">
            <span className="font-pixel text-xs">
              パーティ: {trainer.party.pokemonCount}/6
            </span>
            <PixelProgressBar 
              value={trainer.party.pokemonCount} 
              max={6}
              color="progress"
            />
          </div>
        )}
      </div>
      
      {/* レベル経験値バー */}
      <div className="trainer-card__exp">
        <PixelProgressBar
          value={trainer.job.experience}
          max={trainer.job.nextLevelExp}
          color="exp"
          showLabel={false}
        />
      </div>
    </div>
  );
};

/* CSS */
.trainer-card {
  @apply bg-retro-bg border-2 border-retro-border p-4 rounded-none;
  image-rendering: pixelated;
  transition: all 0.2s ease;
}

.trainer-card--clickable:hover {
  @apply bg-retro-accent transform scale-105;
  cursor: pointer;
}

.trainer-card--busy {
  @apply opacity-75;
  filter: grayscale(30%);
}
```

---

## 4. 状態管理設計

### 4.1 Zustand Store構成

#### ユーザー状態管理
```typescript
// stores/useUserStore.ts
interface UserState {
  user: User | null;
  isAuthenticated: boolean;
  loading: boolean;
  
  // Actions
  login: (credentials: GuestLoginRequest) => Promise<void>;
  logout: () => void;
  updateProfile: (updates: Partial<User>) => Promise<void>;
  refreshUser: () => Promise<void>;
}

export const useUserStore = create<UserState>((set, get) => ({
  user: null,
  isAuthenticated: false,
  loading: false,
  
  login: async (credentials) => {
    set({ loading: true });
    try {
      const response = await authAPI.guestLogin(credentials);
      set({ 
        user: response.data.user, 
        isAuthenticated: true,
        loading: false 
      });
    } catch (error) {
      set({ loading: false });
      throw error;
    }
  },
  
  logout: () => {
    set({ user: null, isAuthenticated: false });
    // Clear localStorage, etc.
  },
  
  updateProfile: async (updates) => {
    const { user } = get();
    if (!user) return;
    
    const response = await userAPI.updateProfile(updates);
    set({ user: response.data });
  },
  
  refreshUser: async () => {
    const response = await userAPI.getProfile();
    set({ user: response.data });
  }
}));
```

#### リアルタイム状態管理
```typescript
// stores/useRealtimeStore.ts
interface RealtimeState {
  expeditions: ActiveExpedition[];
  interventions: InterventionEvent[];
  notifications: Notification[];
  connectionStatus: 'connected' | 'disconnected' | 'reconnecting';
  
  // Actions
  connect: () => void;
  disconnect: () => void;
  addIntervention: (intervention: InterventionEvent) => void;
  removeIntervention: (id: string) => void;
  markNotificationRead: (id: string) => void;
}

export const useRealtimeStore = create<RealtimeState>((set, get) => ({
  expeditions: [],
  interventions: [],
  notifications: [],
  connectionStatus: 'disconnected',
  
  connect: () => {
    const eventSource = new EventSource('/api/v1/realtime/events');
    
    eventSource.onopen = () => {
      set({ connectionStatus: 'connected' });
    };
    
    eventSource.addEventListener('intervention_required', (event) => {
      const intervention = JSON.parse(event.data);
      set(state => ({
        interventions: [...state.interventions, intervention]
      }));
    });
    
    eventSource.addEventListener('expedition_progress', (event) => {
      const expeditionUpdate = JSON.parse(event.data);
      set(state => ({
        expeditions: state.expeditions.map(exp => 
          exp.id === expeditionUpdate.id 
            ? { ...exp, ...expeditionUpdate } 
            : exp
        )
      }));
    });
  },
  
  addIntervention: (intervention) => {
    set(state => ({
      interventions: [...state.interventions, intervention]
    }));
  },
  
  removeIntervention: (id) => {
    set(state => ({
      interventions: state.interventions.filter(i => i.id !== id)
    }));
  }
}));
```

### 4.2 React Query設定

#### API クエリ設定
```typescript
// hooks/useTrainerQueries.ts
export const useTrainerList = (filters: TrainersListQuery = {}) => {
  return useQuery({
    queryKey: ['trainers', 'list', filters],
    queryFn: () => trainerAPI.getTrainerList(filters),
    staleTime: 5 * 60 * 1000, // 5分
    cacheTime: 10 * 60 * 1000, // 10分
  });
};

export const useTrainerDetail = (trainerId: string) => {
  return useQuery({
    queryKey: ['trainers', 'detail', trainerId],
    queryFn: () => trainerAPI.getTrainerDetail(trainerId),
    enabled: !!trainerId,
    staleTime: 2 * 60 * 1000, // 2分
  });
};

export const useUpdateTrainer = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, updates }: { id: string; updates: UpdateTrainerRequest }) =>
      trainerAPI.updateTrainer(id, updates),
    onSuccess: (data, { id }) => {
      // キャッシュ更新
      queryClient.setQueryData(['trainers', 'detail', id], data);
      queryClient.invalidateQueries(['trainers', 'list']);
    },
  });
};
```

---

## 5. レスポンシブ・アクセシビリティ対応

### 5.1 レスポンシブデザイン

#### ブレークポイント設定
```css
/* tailwind.config.js */
module.exports = {
  theme: {
    screens: {
      'xs': '320px',    // モバイル縦
      'sm': '640px',    // モバイル横
      'md': '768px',    // タブレット縦
      'lg': '1024px',   // タブレット横
      'xl': '1280px',   // デスクトップ
      '2xl': '1536px',  // 大型デスクトップ
    }
  }
}
```

#### モバイル対応
```tsx
// components/layout/ResponsiveLayout.tsx
export const ResponsiveLayout: React.FC<{ children: React.ReactNode }> = ({ 
  children 
}) => {
  const [isMobile, setIsMobile] = useState(false);
  
  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768);
    };
    
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);
  
  return (
    <div className={`
      responsive-layout
      ${isMobile ? 'layout-mobile' : 'layout-desktop'}
    `}>
      {isMobile ? (
        <MobileGameBoyLayout>{children}</MobileGameBoyLayout>
      ) : (
        <DesktopGameBoyLayout>{children}</DesktopGameBoyLayout>
      )}
    </div>
  );
};
```

### 5.2 アクセシビリティ

#### キーボードナビゲーション
```tsx
// hooks/useKeyboardNavigation.ts
export const useKeyboardNavigation = (items: any[], onSelect: (item: any) => void) => {
  const [selectedIndex, setSelectedIndex] = useState(0);
  
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      switch (event.key) {
        case 'ArrowUp':
          event.preventDefault();
          setSelectedIndex(prev => 
            prev > 0 ? prev - 1 : items.length - 1
          );
          break;
        case 'ArrowDown':
          event.preventDefault();
          setSelectedIndex(prev => 
            prev < items.length - 1 ? prev + 1 : 0
          );
          break;
        case 'Enter':
        case ' ':
          event.preventDefault();
          onSelect(items[selectedIndex]);
          break;
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [items, selectedIndex, onSelect]);
  
  return { selectedIndex, setSelectedIndex };
};
```

#### ARIA対応
```tsx
// components/ui/PixelMenu.tsx
interface PixelMenuProps {
  items: MenuItem[];
  onSelect: (item: MenuItem) => void;
  ariaLabel: string;
}

export const PixelMenu: React.FC<PixelMenuProps> = ({
  items,
  onSelect,
  ariaLabel
}) => {
  const { selectedIndex } = useKeyboardNavigation(items, onSelect);
  
  return (
    <nav 
      className="pixel-menu"
      role="menu"
      aria-label={ariaLabel}
    >
      {items.map((item, index) => (
        <button
          key={item.id}
          className={`
            pixel-menu-item
            ${index === selectedIndex ? 'pixel-menu-item--selected' : ''}
          `}
          role="menuitem"
          aria-selected={index === selectedIndex}
          onClick={() => onSelect(item)}
        >
          {item.icon && <span aria-hidden="true">{item.icon}</span>}
          <span>{item.label}</span>
        </button>
      ))}
    </nav>
  );
};
```

---

## 6. アニメーション・エフェクト

### 6.1 ページ遷移アニメーション

#### ドット絵風トランジション
```tsx
// components/animations/PixelTransition.tsx
export const PixelTransition: React.FC<{ children: React.ReactNode }> = ({ 
  children 
}) => {
  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.8 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 1.2 }}
      transition={{
        type: "spring",
        damping: 25,
        stiffness: 500,
        duration: 0.3
      }}
    >
      {children}
    </motion.div>
  );
};

// ページ単位での使用
export default function TrainersPage() {
  return (
    <PixelTransition>
      <div className="trainers-page">
        {/* コンテンツ */}
      </div>
    </PixelTransition>
  );
}
```

### 6.2 ゲーム固有アニメーション

#### ポケモン登場アニメーション
```tsx
// components/animations/PokemonAppearAnimation.tsx
interface PokemonAppearAnimationProps {
  pokemon: PokemonInstance;
  onComplete: () => void;
}

export const PokemonAppearAnimation: React.FC<PokemonAppearAnimationProps> = ({
  pokemon,
  onComplete
}) => {
  return (
    <motion.div
      className="pokemon-appear-animation"
      initial={{ x: -200, opacity: 0 }}
      animate={{ x: 0, opacity: 1 }}
      transition={{ duration: 0.8, ease: "easeOut" }}
      onAnimationComplete={onComplete}
    >
      <motion.div
        animate={{ y: [0, -10, 0] }}
        transition={{ 
          duration: 1.5, 
          repeat: Infinity,
          ease: "easeInOut"
        }}
      >
        <PokemonSprite 
          speciesId={pokemon.species.id}
          variant="front"
          size="lg"
          animated
        />
      </motion.div>
      
      {/* "野生の○○が飛び出してきた！"風テキスト */}
      <motion.div
        className="pokemon-appear-text"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ delay: 0.5 }}
      >
        <TypewriterText 
          text={`野生の${pokemon.species.nameJa}が現れた！`}
          speed={50}
        />
      </motion.div>
    </motion.div>
  );
};
```

#### レベルアップエフェクト
```tsx
// components/animations/LevelUpEffect.tsx
export const LevelUpEffect: React.FC<{
  visible: boolean;
  onComplete: () => void;
}> = ({ visible, onComplete }) => {
  if (!visible) return null;
  
  return (
    <motion.div
      className="level-up-effect"
      initial={{ scale: 0, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      exit={{ scale: 1.5, opacity: 0 }}
      transition={{ duration: 0.6 }}
      onAnimationComplete={onComplete}
    >
      <motion.div
        className="level-up-flash"
        animate={{ opacity: [0, 1, 0, 1, 0] }}
        transition={{ duration: 0.8, times: [0, 0.2, 0.4, 0.6, 1] }}
      />
      
      <motion.h2
        className="font-pixel-large text-yellow-400"
        animate={{ y: [20, 0, -10, 0] }}
        transition={{ duration: 0.6 }}
      >
        LEVEL UP!
      </motion.h2>
    </motion.div>
  );
};
```

---

## 7. パフォーマンス最適化

### 7.1 画像最適化

#### ドット絵アセット最適化
```typescript
// utils/imageOptimization.ts
export const optimizePokemonSprites = {
  // Next.js Image設定
  loader: ({ src, width, quality }: ImageLoaderProps) => {
    // ドット絵は拡大時にピクセル補間しない
    const params = new URLSearchParams({
      url: src,
      w: width.toString(),
      q: (quality || 75).toString(),
      auto: 'format',
      fit: 'max',
      // 重要: ドット絵のためpixelatedを維持
      interpolation: 'nearest-neighbor'
    });
    
    return `/api/v1/assets/optimize?${params.toString()}`;
  },
  
  // プリロード戦略
  preloadCriticalSprites: async (pokemonIds: number[]) => {
    const preloadPromises = pokemonIds.map(id => {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.as = 'image';
      link.href = `/api/v1/assets/pokemon/${id}?style=icon&format=webp`;
      document.head.appendChild(link);
    });
    
    await Promise.all(preloadPromises);
  }
};
```

### 7.2 レンダリング最適化

#### 仮想化リスト（大量ポケモン表示用）
```tsx
// components/pokemon/VirtualizedPokemonList.tsx
import { FixedSizeList as List } from 'react-window';

interface VirtualizedPokemonListProps {
  pokemon: PokemonInstance[];
  onSelect: (pokemon: PokemonInstance) => void;
}

export const VirtualizedPokemonList: React.FC<VirtualizedPokemonListProps> = ({
  pokemon,
  onSelect
}) => {
  const Row = useCallback(({ index, style }: ListChildComponentProps) => (
    <div style={style}>
      <PokemonCard 
        pokemon={pokemon[index]}
        onClick={() => onSelect(pokemon[index])}
      />
    </div>
  ), [pokemon, onSelect]);
  
  return (
    <List
      height={400}
      itemCount={pokemon.length}
      itemSize={80}
      className="pokemon-virtual-list"
    >
      {Row}
    </List>
  );
};
```

### 7.3 状態最適化

#### メモ化戦略
```typescript
// hooks/useOptimizedTrainer.ts
export const useOptimizedTrainer = (trainerId: string) => {
  // 基本データ
  const { data: trainer } = useTrainerDetail(trainerId);
  
  // 重い計算結果をメモ化
  const trainerStats = useMemo(() => {
    if (!trainer) return null;
    
    return {
      totalPokemonLevel: trainer.party.reduce((sum, p) => sum + p.level, 0),
      averageLevel: trainer.party.length > 0 
        ? trainer.party.reduce((sum, p) => sum + p.level, 0) / trainer.party.length 
        : 0,
      typeDistribution: calculateTypeDistribution(trainer.party),
      battlePower: calculateBattlePower(trainer.party, trainer.job)
    };
  }, [trainer]);
  
  // パーティ変更の検出
  const partyHash = useMemo(() => 
    trainer?.party.map(p => `${p.id}-${p.level}`).join('|') || '',
    [trainer?.party]
  );
  
  return { trainer, trainerStats, partyHash };
};
```

---

## 8. リアルタイム通信・通知

### 8.1 介入システムUI

#### リアルタイム介入ダイアログ
```tsx
// components/interventions/InterventionDialog.tsx
interface InterventionDialogProps {
  intervention: InterventionEvent;
  onRespond: (choiceId: number) => void;
  onTimeout: () => void;
}

export const InterventionDialog: React.FC<InterventionDialogProps> = ({
  intervention,
  onRespond,
  onTimeout
}) => {
  const [timeRemaining, setTimeRemaining] = useState(intervention.timeRemaining);
  
  useEffect(() => {
    const timer = setInterval(() => {
      setTimeRemaining(prev => {
        if (prev <= 1) {
          onTimeout();
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
    
    return () => clearInterval(timer);
  }, [onTimeout]);
  
  return (
    <PixelDialog open={true} title="緊急事態発生！">
      <div className="intervention-dialog">
        {/* タイマー表示 */}
        <div className="intervention-timer">
          <PixelProgressBar 
            value={timeRemaining}
            max={intervention.timeRemaining}
            color="danger"
            animated
          />
          <span className="font-pixel text-xs">
            残り時間: {timeRemaining}秒
          </span>
        </div>
        
        {/* イベント説明 */}
        <div className="intervention-description">
          <TypewriterText 
            text={intervention.eventData.description}
            speed={30}
          />
        </div>
        
        {/* 選択肢 */}
        <div className="intervention-choices">
          {intervention.choices.map((choice, index) => (
            <PixelButton
              key={choice.id}
              variant={
                choice.risk === 'high' ? 'danger' :
                choice.risk === 'medium' ? 'secondary' :
                'primary'
              }
              onClick={() => onRespond(choice.id)}
            >
              <div className="choice-content">
                <div className="choice-text">{choice.text}</div>
                <div className="choice-risk">
                  リスク: {choice.risk === 'high' ? '高' : choice.risk === 'medium' ? '中' : '低'}
                </div>
              </div>
            </PixelButton>
          ))}
        </div>
      </div>
    </PixelDialog>
  );
};
```

### 8.2 通知システム

#### ドット絵風通知
```tsx
// components/notifications/PixelNotification.tsx
interface PixelNotificationProps {
  notification: Notification;
  onDismiss: (id: string) => void;
}

export const PixelNotification: React.FC<PixelNotificationProps> = ({
  notification,
  onDismiss
}) => {
  return (
    <motion.div
      className={`pixel-notification pixel-notification--${notification.priority}`}
      initial={{ x: 300, opacity: 0 }}
      animate={{ x: 0, opacity: 1 }}
      exit={{ x: 300, opacity: 0 }}
      transition={{ type: "spring", damping: 25, stiffness: 500 }}
    >
      <div className="notification-icon">
        {getNotificationIcon(notification.type)}
      </div>
      
      <div className="notification-content">
        <h4 className="font-pixel">{notification.title}</h4>
        <p className="font-pixel text-xs">{notification.message}</p>
      </div>
      
      <button 
        className="notification-close"
        onClick={() => onDismiss(notification.id)}
        aria-label="通知を閉じる"
      >
        ×
      </button>
    </motion.div>
  );
};

// 通知管理コンテナ
export const NotificationContainer: React.FC = () => {
  const { notifications } = useRealtimeStore();
  
  return (
    <div className="notification-container">
      <AnimatePresence>
        {notifications.map(notification => (
          <PixelNotification 
            key={notification.id}
            notification={notification}
            onDismiss={useRealtimeStore.getState().markNotificationRead}
          />
        ))}
      </AnimatePresence>
    </div>
  );
};
```

---

## 9. テーマ・カスタマイズ

### 9.1 レトロテーマシステム

#### テーマ切り替え
```typescript
// contexts/ThemeContext.tsx
interface RetroTheme {
  name: string;
  colors: {
    primary: string;
    secondary: string;
    background: string;
    text: string;
    border: string;
    accent: string;
  };
  palette: 'gameboy' | 'gameboy_color' | 'custom';
}

const themes: Record<string, RetroTheme> = {
  gameboy_green: {
    name: 'ゲームボーイ（緑）',
    colors: {
      primary: '#9BBD0F',
      secondary: '#8BAC0F',
      background: '#9BBD0F',
      text: '#0F380F',
      border: '#306230',
      accent: '#0F380F'
    },
    palette: 'gameboy'
  },
  gameboy_red: {
    name: 'ポケットモンスター赤',
    colors: {
      primary: '#FF6B6B',
      secondary: '#FF5252',
      background: '#FFF3E0',
      text: '#2C1810',
      border: '#8D4E3C',
      accent: '#FF5722'
    },
    palette: 'gameboy_color'
  },
  gameboy_blue: {
    name: 'ポケットモンスター青',
    colors: {
      primary: '#4FC3F7',
      secondary: '#29B6F6',
      background: '#E3F2FD',
      text: '#0D47A1',
      border: '#1976D2',
      accent: '#2196F3'
    },
    palette: 'gameboy_color'
  }
};

export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ 
  children 
}) => {
  const [currentTheme, setCurrentTheme] = useState<string>('gameboy_green');
  
  useEffect(() => {
    const theme = themes[currentTheme];
    const root = document.documentElement;
    
    Object.entries(theme.colors).forEach(([key, value]) => {
      root.style.setProperty(`--retro-${key}`, value);
    });
  }, [currentTheme]);
  
  return (
    <ThemeContext.Provider value={{ currentTheme, setCurrentTheme, themes }}>
      {children}
    </ThemeContext.Provider>
  );
};
```

### 9.2 ユーザーカスタマイズ

#### 設定パネル
```tsx
// components/settings/RetroThemeSettings.tsx
export const RetroThemeSettings: React.FC = () => {
  const { currentTheme, setCurrentTheme, themes } = useTheme();
  
  return (
    <div className="theme-settings">
      <h3 className="font-pixel-large">テーマ設定</h3>
      
      <div className="theme-grid">
        {Object.entries(themes).map(([key, theme]) => (
          <div
            key={key}
            className={`
              theme-preview
              ${currentTheme === key ? 'theme-preview--selected' : ''}
            `}
            onClick={() => setCurrentTheme(key)}
          >
            <div 
              className="theme-preview__swatch"
              style={{ backgroundColor: theme.colors.primary }}
            />
            <span className="font-pixel text-xs">{theme.name}</span>
          </div>
        ))}
      </div>
      
      {/* プレビュー */}
      <div className="theme-preview-demo">
        <PixelButton variant="primary">サンプルボタン</PixelButton>
        <PixelProgressBar value={75} max={100} color="hp" />
        <div className="font-pixel">サンプルテキスト</div>
      </div>
    </div>
  );
};
```

---

## 10. テスト・品質管理

### 10.1 コンポーネントテスト

#### ドット絵コンポーネントのテスト
```typescript
// __tests__/components/PokemonSprite.test.tsx
import { render, screen } from '@testing-library/react';
import { PokemonSprite } from '@/components/pokemon/PokemonSprite';

describe('PokemonSprite', () => {
  it('ポケモンスプライトが正しく表示される', () => {
    render(
      <PokemonSprite 
        speciesId={25} 
        variant="front" 
        size="md" 
      />
    );
    
    const sprite = screen.getByRole('img');
    expect(sprite).toHaveStyle({ imageRendering: 'pixelated' });
  });
  
  it('アニメーション付きで表示される', () => {
    render(
      <PokemonSprite 
        speciesId={25} 
        variant="front" 
        size="md" 
        animated 
      />
    );
    
    const container = screen.getByText('pokemon-sprite--animated');
    expect(container).toBeInTheDocument();
  });
});
```

### 10.2 アクセシビリティテスト

#### ARIA・キーボードナビゲーションテスト
```typescript
// __tests__/accessibility/KeyboardNavigation.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { PixelMenu } from '@/components/ui/PixelMenu';

describe('Keyboard Navigation', () => {
  const mockItems = [
    { id: '1', label: 'トレーナー管理', icon: '👨‍🏫' },
    { id: '2', label: 'ポケモン管理', icon: '🎾' },
    { id: '3', label: '派遣管理', icon: '🗺️' }
  ];
  
  it('矢印キーでナビゲーションできる', () => {
    const onSelect = jest.fn();
    render(
      <PixelMenu 
        items={mockItems} 
        onSelect={onSelect}
        ariaLabel="メインメニュー"
      />
    );
    
    // 下矢印でフォーカス移動
    fireEvent.keyDown(window, { key: 'ArrowDown' });
    expect(screen.getByText('ポケモン管理')).toHaveAttribute('aria-selected', 'true');
    
    // Enterで選択
    fireEvent.keyDown(window, { key: 'Enter' });
    expect(onSelect).toHaveBeenCalledWith(mockItems[1]);
  });
});
```