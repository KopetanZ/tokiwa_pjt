# ゲームロジック仕様書
**トキワシティ訓練所 - コアアルゴリズム設計**

---

## 1. ゲームロジック概要

### 1.1 設計原則
- **決定論的ランダム**: シード値による再現可能な乱数
- **段階的成長**: 指数関数的ではなく線形〜対数的な成長カーブ
- **バランス重視**: 課金なしでも十分楽しめる設計
- **介入価値**: プレイヤーの判断が15-25%の効果を持つ
- **長期継続**: 数ヶ月〜年単位でのプレイ継続を想定

### 1.2 核となるパラメータ
```typescript
// config/gameBalance.ts
export const GAME_BALANCE = {
  // 基礎設定
  MAX_TRAINER_LEVEL: 50,
  MAX_POKEMON_LEVEL: 100,
  MAX_PARTY_SIZE: 6,
  
  // 時間設定
  MIN_EXPEDITION_HOURS: 1,
  MAX_EXPEDITION_HOURS: 72,
  INTERVENTION_WINDOW_SECONDS: 30,
  
  // 経済バランス
  STARTING_MONEY: 50000,
  BASE_TRAINER_SALARY: 3000,
  SALARY_LEVEL_MULTIPLIER: 1.2,
  
  // 成功率補正
  PLAYER_INTERVENTION_BONUS: 0.15, // 15%向上
  TRUST_LEVEL_MAX_BONUS: 0.25,     // 最大25%向上
  FACILITY_MAX_BONUS: 0.30,        // 施設最大30%向上
  
  // 確率設定
  RARE_POKEMON_BASE_RATE: 0.05,    // 5%
  INTERVENTION_EVENT_RATE: 0.20,   // 20%（1時間あたり）
  CRITICAL_EVENT_RATE: 0.05,       // 5%（緊急事態）
};
```

---

## 2. 派遣システムアルゴリズム

### 2.1 派遣成功率計算

#### 基礎成功率計算式
```typescript
interface ExpeditionSuccessParams {
  trainer: Trainer;
  location: ExpeditionLocation;
  party: PokemonInstance[];
  facilities: Facility[];
  playerAdvice: PlayerAdvice[];
}

function calculateExpeditionSuccess(params: ExpeditionSuccessParams): number {
  const {trainer, location, party, facilities, playerAdvice} = params;
  
  // 1. ベース成功率（場所の難易度による）
  const baseSuccessRate = Math.max(0.3, 1.0 - (location.distanceLevel * 0.15));
  
  // 2. トレーナー職業補正
  const jobMultiplier = getJobMultiplier(trainer.job, location.type);
  
  // 3. パーティ戦力計算
  const partyPower = calculatePartyPower(party, location);
  const partyMultiplier = Math.min(2.0, 0.5 + (partyPower / 1000));
  
  // 4. 施設効果
  const facilityMultiplier = calculateFacilityBonus(facilities, 'expedition_success');
  
  // 5. 信頼度・アドバイス効果
  const trustMultiplier = 1.0 + (trainer.trustLevel / 100) * GAME_BALANCE.TRUST_LEVEL_MAX_BONUS;
  const adviceMultiplier = calculateAdviceEffect(playerAdvice, trainer.complianceRate);
  
  // 最終成功率計算
  const finalSuccessRate = baseSuccessRate 
    * jobMultiplier 
    * partyMultiplier 
    * facilityMultiplier 
    * trustMultiplier 
    * adviceMultiplier;
  
  return Math.min(0.95, Math.max(0.05, finalSuccessRate));
}

// 職業による場所適性
function getJobMultiplier(job: TrainerJob, locationType: string): number {
  const specializations = job.specializations;
  
  switch (locationType) {
    case 'forest':
      return 0.8 + (specializations.exploration || 0) * 0.4;
    case 'cave':
      return 0.7 + (specializations.cave_exploration || 0) * 0.6;
    case 'gym':
      return 0.6 + (specializations.battle || 0) * 0.8;
    case 'water':
      return 0.9 + (specializations.water_adaptation || 0) * 0.2;
    default:
      return 1.0;
  }
}
```

#### パーティ戦力計算
```typescript
function calculatePartyPower(party: PokemonInstance[], location: ExpeditionLocation): number {
  let totalPower = 0;
  
  for (const pokemon of party) {
    // 基礎戦力（レベル + 種族値）
    const basePower = pokemon.level * 10 + calculateSpeciesPower(pokemon.species);
    
    // タイプ相性補正
    const typeMultiplier = calculateTypeAdvantage(pokemon.species.types, location.encounterTypes);
    
    // 個体値補正
    const ivMultiplier = 0.8 + (calculateAverageIV(pokemon.individualValues) / 31) * 0.4;
    
    // HP状態補正
    const hpMultiplier = pokemon.currentHp / pokemon.maxHp;
    
    const pokemonPower = basePower * typeMultiplier * ivMultiplier * hpMultiplier;
    totalPower += pokemonPower;
  }
  
  // パーティサイズボーナス（6体満員で+20%）
  const sizeBonus = 1.0 + (party.length / 6) * 0.2;
  
  return totalPower * sizeBonus;
}

function calculateSpeciesPower(species: PokemonSpecies): number {
  const stats = species.baseStats;
  
  // 戦闘力 = HP*0.3 + Attack*0.4 + Defense*0.3
  const battlePower = stats.hp * 0.3 + stats.attack * 0.4 + stats.defense * 0.3;
  
  // 探索力 = Speed*0.5 + (Special Attack + Special Defense)*0.25
  const explorationPower = stats.speed * 0.5 + (stats.specialAttack + stats.specialDefense) * 0.25;
  
  return (battlePower + explorationPower) / 2;
}
```

### 2.2 派遣進行シミュレーション

#### タイムステップ処理
```typescript
interface ExpeditionState {
  progress: number;        // 0.0 - 1.0
  currentHp: number[];     // パーティの現在HP
  events: ExpeditionEvent[];
  resources: {
    money: number;
    experience: number;
    items: Item[];
    pokemonEncountered: PokemonEncounter[];
  };
}

function simulateExpeditionStep(
  expedition: Expedition,
  state: ExpeditionState,
  stepSizeMinutes: number
): ExpeditionState {
  
  const newState = { ...state };
  
  // 1. 進行度更新
  const progressIncrement = stepSizeMinutes / (expedition.targetDurationHours * 60);
  newState.progress = Math.min(1.0, state.progress + progressIncrement);
  
  // 2. ランダムイベント判定
  if (shouldTriggerEvent(expedition, stepSizeMinutes)) {
    const event = generateRandomEvent(expedition, state);
    newState.events.push(event);
    
    // イベントによる即座の影響
    applyEventEffects(event, newState);
  }
  
  // 3. 継続的な効果（HP回復、経験値獲得等）
  applyContinuousEffects(expedition, newState, stepSizeMinutes);
  
  // 4. リソース獲得
  if (newState.progress >= 1.0) {
    calculateFinalRewards(expedition, newState);
  }
  
  return newState;
}

function shouldTriggerEvent(expedition: Expedition, stepSizeMinutes: number): boolean {
  // 1時間あたり20%の確率でイベント発生
  const hourlyRate = GAME_BALANCE.INTERVENTION_EVENT_RATE;
  const stepRate = hourlyRate * (stepSizeMinutes / 60);
  
  return Math.random() < stepRate;
}
```

#### ランダムイベント生成
```typescript
type EventType = 
  | 'pokemon_encounter' 
  | 'rare_pokemon_found' 
  | 'trainer_injured' 
  | 'valuable_item_found'
  | 'dangerous_path'
  | 'weather_change';

function generateRandomEvent(expedition: Expedition, state: ExpeditionState): ExpeditionEvent {
  const eventType = selectEventType(expedition.location, state.progress);
  
  switch (eventType) {
    case 'rare_pokemon_found':
      return generateRarePokemonEvent(expedition, state);
    
    case 'dangerous_path':
      return generateDangerousPathEvent(expedition, state);
    
    case 'valuable_item_found':
      return generateItemFindEvent(expedition, state);
    
    default:
      return generateBasicEvent(eventType, expedition, state);
  }
}

function generateRarePokemonEvent(
  expedition: Expedition, 
  state: ExpeditionState
): ExpeditionEvent {
  
  const rarePokemon = selectRarePokemon(expedition.location);
  const captureRate = calculateCaptureRate(rarePokemon, expedition.trainer.party);
  
  return {
    id: generateId(),
    type: 'rare_pokemon_found',
    title: `野生の${rarePokemon.nameJa}を発見！`,
    description: `珍しい${rarePokemon.nameJa}を発見しました。捕獲を試みますか？`,
    
    choices: [
      {
        id: 1,
        text: '捕獲を試みる',
        risk: 'medium',
        effects: {
          successRate: captureRate,
          successReward: { pokemon: rarePokemon },
          failurePenalty: { hpDamage: 15, time: 30 }
        }
      },
      {
        id: 2,
        text: '無視して先に進む',
        risk: 'low',
        effects: {
          successRate: 1.0,
          successReward: { experience: 50 }
        }
      },
      {
        id: 3,
        text: '慎重に観察してから判断',
        risk: 'low',
        effects: {
          successRate: captureRate * 1.2,
          successReward: { pokemon: rarePokemon, experience: 25 },
          time: 15
        }
      }
    ],
    
    deadline: Date.now() + GAME_BALANCE.INTERVENTION_WINDOW_SECONDS * 1000,
    autoChoice: 2 // タイムアウト時の自動選択
  };
}
```

---

## 3. バトル判定システム

### 3.1 バトル勝率計算

#### チーム戦力スコア算出
```typescript
interface BattleParticipant {
  pokemon: PokemonInstance[];
  trainer?: Trainer;
  bonuses?: Record<string, number>;
}

function calculateTeamBattlePower(participant: BattleParticipant): number {
  let totalPower = 0;
  
  for (const pokemon of participant.pokemon) {
    const individualPower = calculateIndividualBattlePower(pokemon);
    totalPower += individualPower;
  }
  
  // トレーナーボーナス
  if (participant.trainer) {
    const trainerBonus = 1.0 + (participant.trainer.job.specializations.battle || 0) * 0.3;
    totalPower *= trainerBonus;
  }
  
  // 施設・装備ボーナス
  const facilityBonus = participant.bonuses?.facility || 1.0;
  const equipmentBonus = participant.bonuses?.equipment || 1.0;
  
  return totalPower * facilityBonus * equipmentBonus;
}

function calculateIndividualBattlePower(pokemon: PokemonInstance): number {
  const species = pokemon.species;
  const level = pokemon.level;
  
  // 基礎ステータス計算
  const hp = calculateStat(species.baseStats.hp, level, pokemon.individualValues.hp);
  const attack = calculateStat(species.baseStats.attack, level, pokemon.individualValues.attack);
  const defense = calculateStat(species.baseStats.defense, level, pokemon.individualValues.defense);
  const speed = calculateStat(species.baseStats.speed, level, pokemon.individualValues.speed);
  
  // 戦闘力合成（攻撃力と耐久力のバランス）
  const offensivePower = attack * 1.2 + species.baseStats.specialAttack * 0.8;
  const defensivePower = (hp * defense) / 100;
  const mobilityPower = speed * 0.5;
  
  const totalPower = (offensivePower + defensivePower + mobilityPower) / 3;
  
  // HP状態による補正
  const hpRatio = pokemon.currentHp / hp;
  const hpPenalty = 0.3 + hpRatio * 0.7; // 30%〜100%
  
  return totalPower * hpPenalty;
}

function calculateStat(baseStat: number, level: number, iv: number): number {
  // ポケモン本家の計算式を簡略化
  return Math.floor(((baseStat * 2 + iv) * level) / 100) + 5;
}
```

#### 勝敗判定ロジック
```typescript
function determineBattleOutcome(teamA: BattleParticipant, teamB: BattleParticipant): BattleResult {
  const powerA = calculateTeamBattlePower(teamA);
  const powerB = calculateTeamBattlePower(teamB);
  
  // 基本勝率計算（シグモイド関数）
  const powerRatio = powerA / (powerA + powerB);
  const baseWinRate = 1 / (1 + Math.exp(-5 * (powerRatio - 0.5)));
  
  // ランダム要素（±15%程度のブレ）
  const randomFactor = 0.85 + Math.random() * 0.3;
  const finalWinRate = Math.min(0.95, Math.max(0.05, baseWinRate * randomFactor));
  
  const victory = Math.random() < finalWinRate;
  
  return {
    victory,
    winRate: finalWinRate,
    damageDealt: calculateBattleDamage(teamA, teamB, victory),
    experienceGained: calculateBattleExperience(teamA, teamB, victory),
    rewards: victory ? generateBattleRewards(teamB) : null
  };
}

function calculateBattleDamage(
  attacker: BattleParticipant, 
  defender: BattleParticipant,
  attackerVictory: boolean
): PokemonDamage[] {
  
  const damages: PokemonDamage[] = [];
  
  for (let i = 0; i < attacker.pokemon.length; i++) {
    const pokemon = attacker.pokemon[i];
    const maxHp = calculateStat(pokemon.species.baseStats.hp, pokemon.level, pokemon.individualValues.hp);
    
    // 勝利側は軽傷、敗北側は重傷
    const damageRatio = attackerVictory 
      ? 0.1 + Math.random() * 0.2  // 10-30%のダメージ
      : 0.3 + Math.random() * 0.4; // 30-70%のダメージ
    
    const damage = Math.floor(maxHp * damageRatio);
    const newHp = Math.max(1, pokemon.currentHp - damage);
    
    damages.push({
      pokemonId: pokemon.id,
      damageAmount: damage,
      newHp: newHp,
      fainted: newHp <= 1
    });
  }
  
  return damages;
}
```

---

## 4. ポケモン捕獲システム

### 4.1 捕獲確率計算

#### 基本捕獲率算出
```typescript
interface CaptureAttempt {
  pokemon: PokemonSpecies;
  trainerParty: PokemonInstance[];
  location: ExpeditionLocation;
  trainer: Trainer;
  weather?: WeatherCondition;
  timeOfDay?: 'morning' | 'day' | 'evening' | 'night';
}

function calculateCaptureRate(attempt: CaptureAttempt): number {
  const {pokemon, trainerParty, location, trainer, weather, timeOfDay} = attempt;
  
  // 1. ベース捕獲率（PokeAPIの値を使用）
  let baseCaptureRate = pokemon.catchRate / 255; // 0.0-1.0に正規化
  
  // 2. レベル差補正
  const averagePartyLevel = trainerParty.reduce((sum, p) => sum + p.level, 0) / trainerParty.length;
  const levelDifference = averagePartyLevel - (pokemon.baseStats.hp / 10); // レベル推定
  const levelMultiplier = 1.0 + (levelDifference * 0.02); // ±2%/レベル
  
  // 3. トレーナー職業補正
  const jobMultiplier = 1.0 + (trainer.job.specializations.capture || 0);
  
  // 4. 場所補正
  const locationMultiplier = getLocationCaptureMultiplier(location, pokemon);
  
  // 5. 天候・時間補正
  const environmentMultiplier = getEnvironmentMultiplier(pokemon, weather, timeOfDay);
  
  // 6. パーティ状態補正（弱らせた効果）
  const partyConditionMultiplier = calculatePartyConditionBonus(trainerParty);
  
  const finalCaptureRate = baseCaptureRate 
    * levelMultiplier 
    * jobMultiplier 
    * locationMultiplier 
    * environmentMultiplier 
    * partyConditionMultiplier;
  
  return Math.min(0.95, Math.max(0.01, finalCaptureRate));
}

function getLocationCaptureMultiplier(location: ExpeditionLocation, pokemon: PokemonSpecies): number {
  // ポケモンのタイプと場所の相性
  const locationTypes = getLocationTypes(location);
  const pokemonTypes = pokemon.types;
  
  const typeMatch = pokemonTypes.some(type => locationTypes.includes(type));
  return typeMatch ? 1.2 : 0.9; // 相性良い場所では+20%、悪いと-10%
}

function getEnvironmentMultiplier(
  pokemon: PokemonSpecies, 
  weather?: WeatherCondition, 
  timeOfDay?: string
): number {
  let multiplier = 1.0;
  
  // 天候効果
  if (weather) {
    const weatherTypeBonus = getWeatherTypeBonus(pokemon.types, weather);
    multiplier *= weatherTypeBonus;
  }
  
  // 時間帯効果
  if (timeOfDay) {
    const timeBonus = getTimeOfDayBonus(pokemon, timeOfDay);
    multiplier *= timeBonus;
  }
  
  return multiplier;
}
```

### 4.2 捕獲試行処理

#### 捕獲ロジック実装
```typescript
function attemptCapture(attempt: CaptureAttempt): CaptureResult {
  const captureRate = calculateCaptureRate(attempt);
  const success = Math.random() < captureRate;
  
  if (success) {
    const caughtPokemon = generateCaughtPokemon(attempt.pokemon, attempt.location);
    return {
      success: true,
      pokemon: caughtPokemon,
      captureRate,
      experience: calculateCaptureExperience(attempt.pokemon),
      message: `${attempt.pokemon.nameJa}を捕まえた！`
    };
  } else {
    return {
      success: false,
      captureRate,
      damage: calculateCaptureDamage(attempt.trainerParty),
      message: `${attempt.pokemon.nameJa}に逃げられた...`,
      experience: Math.floor(calculateCaptureExperience(attempt.pokemon) * 0.3)
    };
  }
}

function generateCaughtPokemon(species: PokemonSpecies, location: ExpeditionLocation): PokemonInstance {
  // レベル決定（場所の危険度に応じて）
  const minLevel = Math.max(1, location.distanceLevel * 3 - 2);
  const maxLevel = location.distanceLevel * 8 + 5;
  const level = minLevel + Math.floor(Math.random() * (maxLevel - minLevel + 1));
  
  // 個体値生成（完全ランダム）
  const individualValues = {
    hp: Math.floor(Math.random() * 32),
    attack: Math.floor(Math.random() * 32),
    defense: Math.floor(Math.random() * 32),
    specialAttack: Math.floor(Math.random() * 32),
    specialDefense: Math.floor(Math.random() * 32),
    speed: Math.floor(Math.random() * 32)
  };
  
  // HP計算
  const maxHp = calculateStat(species.baseStats.hp, level, individualValues.hp);
  
  return {
    id: generateId(),
    species,
    level,
    experience: calculateExperienceForLevel(level),
    individualValues,
    currentHp: maxHp,
    maxHp,
    statusCondition: 'healthy',
    moves: generateRandomMoves(species, level),
    caughtAt: new Date().toISOString(),
    caughtLocation: location.locationNameJa
  };
}
```

---

## 5. 経済システム

### 5.1 収入計算

#### 派遣報酬算出
```typescript
function calculateExpeditionReward(
  expedition: Expedition, 
  result: ExpeditionResult
): EconomicReward {
  
  const location = expedition.location;
  const trainer = expedition.trainer;
  
  // 1. ベース報酬
  let baseReward = location.baseRewardMoney;
  
  // 2. 成功度補正
  const successMultiplier = 0.3 + result.successRate * 0.7; // 30%-100%
  
  // 3. 距離・リスク補正
  const distanceMultiplier = 1.0 + location.distanceLevel * 0.25;
  
  // 4. トレーナー職業補正
  const jobMultiplier = 1.0 + (trainer.job.specializations.income || 0);
  
  // 5. 捕獲ボーナス
  const captureBonus = result.pokemonCaught.length * 500;
  
  // 6. 発見ボーナス
  const discoveryBonus = result.itemsFound.reduce((sum, item) => sum + item.value, 0);
  
  const totalReward = Math.floor(
    baseReward * successMultiplier * distanceMultiplier * jobMultiplier
  ) + captureBonus + discoveryBonus;
  
  return {
    baseAmount: totalReward,
    breakdown: {
      base: Math.floor(baseReward * successMultiplier * distanceMultiplier * jobMultiplier),
      captureBonus,
      discoveryBonus,
      total: totalReward
    }
  };
}
```

### 5.2 支出計算

#### 月次固定費算出
```typescript
function calculateMonthlyCosts(school: School): MonthlyCosts {
  const trainers = school.trainers;
  const facilities = school.facilities;
  
  // トレーナー給与
  const salaryTotal = trainers.reduce((sum, trainer) => {
    const baseSalary = GAME_BALANCE.BASE_TRAINER_SALARY;
    const levelMultiplier = Math.pow(GAME_BALANCE.SALARY_LEVEL_MULTIPLIER, trainer.job.level - 1);
    const jobMultiplier = getJobSalaryMultiplier(trainer.job.jobName);
    
    return sum + Math.floor(baseSalary * levelMultiplier * jobMultiplier);
  }, 0);
  
  // 施設維持費
  const facilityTotal = facilities.reduce((sum, facility) => {
    const baseCost = facility.maintenanceCost;
    const levelMultiplier = Math.pow(1.5, facility.level - 1);
    
    return sum + Math.floor(baseCost * levelMultiplier);
  }, 0);
  
  // その他固定費
  const utilityCost = Math.floor(school.size * 100); // 施設規模による
  const insuranceCost = Math.floor(trainers.length * 500); // トレーナー数による
  
  return {
    salaries: salaryTotal,
    facilities: facilityTotal,
    utilities: utilityCost,
    insurance: insuranceCost,
    total: salaryTotal + facilityTotal + utilityCost + insuranceCost
  };
}

function getJobSalaryMultiplier(jobName: string): number {
  const multipliers: Record<string, number> = {
    'ranger': 1.0,      // 標準
    'breeder': 1.1,     // +10% (専門性)
    'battler': 1.2,     // +20% (高リスク)
    'researcher': 1.3,  // +30% (高度な知識)
    'medic': 1.4,       // +40% (医療専門)
    'economist': 1.1,   // +10% (金融専門)
    'explorer': 1.15    // +15% (危険地帯)
  };
  
  return multipliers[jobName] || 1.0;
}
```

### 5.3 経済バランス調整

#### 収支予測システム
```typescript
function projectEconomicBalance(
  school: School, 
  monthsAhead: number
): EconomicProjection {
  
  const currentBalance = school.currentMoney;
  const monthlyCosts = calculateMonthlyCosts(school);
  
  // 過去の収入パターンから予測
  const historicalIncome = getHistoricalMonthlyIncome(school, 3); // 過去3ヶ月
  const averageIncome = historicalIncome.reduce((sum, income) => sum + income, 0) / historicalIncome.length;
  
  // トレンド考慮（スクールの成長/衰退）
  const growthTrend = calculateGrowthTrend(historicalIncome);
  
  const projections: MonthlyProjection[] = [];
  let runningBalance = currentBalance;
  
  for (let month = 1; month <= monthsAhead; month++) {
    const projectedIncome = averageIncome * Math.pow(growthTrend, month);
    const projectedExpenses = monthlyCosts.total * Math.pow(1.02, month); // 2%年間インフレ
    
    const netIncome = projectedIncome - projectedExpenses;
    runningBalance += netIncome;
    
    projections.push({
      month,
      income: projectedIncome,
      expenses: projectedExpenses,
      netIncome,
      balance: runningBalance,
      isDeficit: netIncome < 0,
      riskLevel: runningBalance < projectedExpenses ? 'high' : runningBalance < projectedExpenses * 2 ? 'medium' : 'low'
    });
  }
  
  return {
    currentBalance,
    projections,
    recommendations: generateEconomicRecommendations(projections)
  };
}
```

---

## 6. トレーナー成長システム

### 6.1 職業レベリング

#### 経験値計算
```typescript
function calculateJobExperience(action: TrainerAction, trainer: Trainer): number {
  const baseExp = getBaseExperienceForAction(action.type);
  
  // 職業適性による補正
  const jobMultiplier = getJobExperienceMultiplier(trainer.job.jobName, action.type);
  
  // 成功度による補正
  const successMultiplier = 0.3 + action.successRate * 0.7;
  
  // レベル補正（高レベルほど獲得しにくい）
  const levelPenalty = Math.pow(0.95, trainer.job.level - 1);
  
  return Math.floor(baseExp * jobMultiplier * successMultiplier * levelPenalty);
}

function getBaseExperienceForAction(actionType: string): number {
  const expValues: Record<string, number> = {
    'expedition_complete': 100,
    'pokemon_capture': 50,
    'battle_victory': 75,
    'rare_pokemon_found': 150,
    'facility_improvement': 25,
    'training_session': 30
  };
  
  return expValues[actionType] || 10;
}

function getJobExperienceMultiplier(jobName: string, actionType: string): number {
  const multipliers: Record<string, Record<string, number>> = {
    'ranger': {
      'pokemon_capture': 1.5,
      'expedition_complete': 1.2,
      'rare_pokemon_found': 2.0
    },
    'battler': {
      'battle_victory': 1.8,
      'expedition_complete': 1.1,
      'pokemon_capture': 0.8
    },
    'breeder': {
      'pokemon_capture': 1.3,
      'pokemon_healing': 2.0,
      'pokemon_evolution': 1.5
    }
    // ... 他の職業
  };
  
  return multipliers[jobName]?.[actionType] || 1.0;
}
```

### 6.2 信頼度システム

#### 信頼度変動計算
```typescript
function updateTrustLevel(
  trainer: Trainer, 
  playerAction: PlayerAction,
  outcome: ActionOutcome
): TrustLevelChange {
  
  let trustChange = 0;
  
  switch (playerAction.type) {
    case 'advice_given':
      const adviceQuality = calculateAdviceQuality(playerAction, outcome);
      if (adviceQuality > 0.7) {
        trustChange = +2; // 良いアドバイス
      } else if (adviceQuality < 0.3) {
        trustChange = -1; // 悪いアドバイス
      }
      break;
      
    case 'intervention_response':
      if (outcome.successful) {
        trustChange = +3; // 的確な判断
      } else {
        trustChange = -2; // 判断ミス
      }
      break;
      
    case 'salary_increase':
      trustChange = +1;
      break;
      
    case 'salary_decrease':
      trustChange = -3;
      break;
  }
  
  // 現在の信頼度による補正（低いときは上がりやすく、高いときは変化しにくく）
  const currentTrustLevel = trainer.trustLevel;
  if (trustChange > 0) {
    trustChange = Math.ceil(trustChange * (1.0 - currentTrustLevel / 100));
  } else {
    trustChange = Math.floor(trustChange * (0.5 + currentTrustLevel / 200));
  }
  
  const newTrustLevel = Math.max(0, Math.min(100, currentTrustLevel + trustChange));
  
  return {
    previousLevel: currentTrustLevel,
    newLevel: newTrustLevel,
    change: trustChange,
    reason: getTrustChangeReason(playerAction, outcome)
  };
}
```

---

## 7. リアルタイム介入システム

### 7.1 介入イベント生成

#### イベント発生判定
```typescript
function checkForInterventionEvents(expedition: Expedition): InterventionEvent | null {
  const progress = expedition.currentProgress;
  const timeSinceLastEvent = Date.now() - expedition.lastEventTime;
  
  // 基本発生率（進行度と時間経過による）
  const baseRate = GAME_BALANCE.INTERVENTION_EVENT_RATE; // 20%/hour
  const progressMultiplier = getProgressEventMultiplier(progress);
  const timeMultiplier = timeSinceLastEvent / (60 * 60 * 1000); // 時間経過
  
  const eventProbability = baseRate * progressMultiplier * timeMultiplier;
  
  if (Math.random() < eventProbability) {
    return generateInterventionEvent(expedition);
  }
  
  return null;
}

function getProgressEventMultiplier(progress: number): number {
  // 序盤・終盤でイベント発生率上昇
  if (progress < 0.2 || progress > 0.8) {
    return 1.5;
  } else if (progress >= 0.4 && progress <= 0.6) {
    return 0.8; // 中盤は落ち着く
  } else {
    return 1.0;
  }
}

function generateInterventionEvent(expedition: Expedition): InterventionEvent {
  const eventTypes = getAvailableEventTypes(expedition);
  const eventType = selectRandomWeighted(eventTypes);
  
  switch (eventType) {
    case 'rare_pokemon_encounter':
      return createRarePokemonEvent(expedition);
    
    case 'path_choice':
      return createPathChoiceEvent(expedition);
    
    case 'weather_event':
      return createWeatherEvent(expedition);
    
    case 'trainer_condition':
      return createTrainerConditionEvent(expedition);
    
    default:
      return createGenericEvent(expedition);
  }
}
```

### 7.2 選択肢評価システム

#### AI推奨システム
```typescript
function generateChoiceRecommendation(
  event: InterventionEvent,
  expedition: Expedition
): ChoiceRecommendation {
  
  const evaluations = event.choices.map(choice => 
    evaluateChoice(choice, expedition)
  );
  
  // 最適選択の決定
  const bestChoice = evaluations.reduce((best, current) => 
    current.expectedValue > best.expectedValue ? current : best
  );
  
  return {
    recommendedChoiceId: bestChoice.choiceId,
    confidence: bestChoice.confidence,
    reasoning: bestChoice.reasoning,
    alternatives: evaluations
      .filter(e => e.choiceId !== bestChoice.choiceId)
      .sort((a, b) => b.expectedValue - a.expectedValue)
      .slice(0, 2) // 上位2つの代替案
  };
}

function evaluateChoice(choice: InterventionChoice, expedition: Expedition): ChoiceEvaluation {
  const effects = choice.effects;
  let expectedValue = 0;
  let confidence = 1.0;
  
  // リワード期待値計算
  if (effects.successReward) {
    const successValue = calculateRewardValue(effects.successReward);
    expectedValue += successValue * (effects.successRate || 0.5);
  }
  
  // ペナルティ期待値計算
  if (effects.failurePenalty) {
    const penaltyValue = calculatePenaltyValue(effects.failurePenalty);
    expectedValue -= penaltyValue * (1 - (effects.successRate || 0.5));
  }
  
  // リスク調整
  const riskMultiplier = getRiskMultiplier(choice.risk);
  expectedValue *= riskMultiplier;
  
  // 現在の遠征状況による補正
  const contextMultiplier = getContextMultiplier(expedition);
  expectedValue *= contextMultiplier;
  
  return {
    choiceId: choice.id,
    expectedValue,
    confidence,
    reasoning: generateReasoning(choice, expedition, expectedValue)
  };
}
```

---

## 8. 確率・ランダム要素管理

### 8.1 疑似乱数生成

#### シード管理システム
```typescript
class GameRandom {
  private seed: number;
  private state: number;
  
  constructor(seed?: number) {
    this.seed = seed || Date.now();
    this.state = this.seed;
  }
  
  // Linear Congruential Generator
  next(): number {
    this.state = (this.state * 1664525 + 1013904223) % Math.pow(2, 32);
    return this.state / Math.pow(2, 32);
  }
  
  // 範囲指定ランダム
  range(min: number, max: number): number {
    return min + this.next() * (max - min);
  }
  
  // 整数ランダム
  integer(min: number, max: number): number {
    return Math.floor(this.range(min, max + 1));
  }
  
  // 確率判定
  chance(probability: number): boolean {
    return this.next() < probability;
  }
  
  // 重み付き選択
  weightedChoice<T>(choices: Array<{item: T, weight: number}>): T {
    const totalWeight = choices.reduce((sum, choice) => sum + choice.weight, 0);
    let random = this.next() * totalWeight;
    
    for (const choice of choices) {
      random -= choice.weight;
      if (random <= 0) {
        return choice.item;
      }
    }
    
    return choices[choices.length - 1].item;
  }
  
  // ガウシアン分布（Box-Muller変換）
  gaussian(mean: number = 0, stdDev: number = 1): number {
    if (this.hasSpare) {
      this.hasSpare = false;
      return this.spare * stdDev + mean;
    }
    
    this.hasSpare = true;
    const u = this.next();
    const v = this.next();
    const mag = stdDev * Math.sqrt(-2 * Math.log(u));
    this.spare = mag * Math.cos(2 * Math.PI * v);
    
    return mag * Math.sin(2 * Math.PI * v) + mean;
  }
  
  private hasSpare: boolean = false;
  private spare: number = 0;
}

// グローバルインスタンス
export const gameRandom = new GameRandom();
```

### 8.2 確率分布管理

#### レア度別出現率設定
```typescript
interface RarityDistribution {
  common: number;    // 60%
  uncommon: number;  // 25%
  rare: number;      // 10%
  veryRare: number;  // 4%
  legendary: number; // 1%
}

const RARITY_DISTRIBUTION: RarityDistribution = {
  common: 0.60,
  uncommon: 0.25,
  rare: 0.10,
  veryRare: 0.04,
  legendary: 0.01
};

function selectPokemonByRarity(
  availablePokemon: PokemonSpecies[],
  location: ExpeditionLocation
): PokemonSpecies {
  
  // 場所による希少度補正
  const rarityBonus = location.distanceLevel * 0.1; // 遠方ほどレア率上昇
  
  const adjustedDistribution = {
    common: Math.max(0.2, RARITY_DISTRIBUTION.common - rarityBonus),
    uncommon: RARITY_DISTRIBUTION.uncommon,
    rare: RARITY_DISTRIBUTION.rare + rarityBonus * 0.5,
    veryRare: RARITY_DISTRIBUTION.veryRare + rarityBonus * 0.3,
    legendary: Math.min(0.1, RARITY_DISTRIBUTION.legendary + rarityBonus * 0.2)
  };
  
  const selectedRarity = gameRandom.weightedChoice([
    { item: 'common', weight: adjustedDistribution.common },
    { item: 'uncommon', weight: adjustedDistribution.uncommon },
    { item: 'rare', weight: adjustedDistribution.rare },
    { item: 'veryRare', weight: adjustedDistribution.veryRare },
    { item: 'legendary', weight: adjustedDistribution.legendary }
  ]);
  
  const pokemonOfRarity = availablePokemon.filter(p => p.rarityTier === getRarityTier(selectedRarity));
  return gameRandom.weightedChoice(
    pokemonOfRarity.map(p => ({ item: p, weight: 1 }))
  );
}
```

---

## 9. バランス調整システム

### 9.1 動的難易度調整

#### プレイヤー進行度による調整
```typescript
function getDynamicBalanceMultiplier(player: User): BalanceMultiplier {
  const stats = calculatePlayerStats(player);
  
  // プレイヤーの進行度評価
  const progressScore = calculateProgressScore(stats);
  
  // 難易度調整曲線（S字カーブ）
  const difficultyMultiplier = 0.5 + 1.0 / (1 + Math.exp(-5 * (progressScore - 0.5)));
  
  // 成功率調整（うまくいきすぎている場合は少し困難に）
  const recentSuccessRate = calculateRecentSuccessRate(player, 10); // 過去10回の派遣
  let successAdjustment = 1.0;
  
  if (recentSuccessRate > 0.8) {
    successAdjustment = 0.9; // 成功率が高すぎる場合は少し下げる
  } else if (recentSuccessRate < 0.3) {
    successAdjustment = 1.1; // 成功率が低すぎる場合は少し上げる
  }
  
  return {
    difficulty: difficultyMultiplier,
    successRate: successAdjustment,
    rewardMultiplier: 1.0 / difficultyMultiplier, // 難易度が高いほど報酬も高く
    reasoning: generateBalanceReasoning(progressScore, recentSuccessRate)
  };
}

function calculateProgressScore(stats: PlayerStats): number {
  // 0.0-1.0のスコア
  const trainerLevelScore = Math.min(1.0, stats.averageTrainerLevel / 30);
  const pokemonLevelScore = Math.min(1.0, stats.averagePokemonLevel / 50);
  const facilityScore = Math.min(1.0, stats.totalFacilityLevel / 50);
  const achievementScore = Math.min(1.0, stats.achievementsUnlocked / 100);
  
  return (trainerLevelScore + pokemonLevelScore + facilityScore + achievementScore) / 4;
}
```

### 9.2 A/Bテスト基盤

#### バランス実験システム
```typescript
interface BalanceExperiment {
  id: string;
  name: string;
  description: string;
  startDate: Date;
  endDate: Date;
  targetPlayers?: string[]; // 特定プレイヤーのみ
  
  // 実験パラメータ
  parameters: {
    [key: string]: {
      control: number;    // コントロール群の値
      treatment: number;  // 実験群の値
    };
  };
  
  // 成功指標
  metrics: {
    primary: string;      // 主要指標（例：retention_rate）
    secondary: string[];  // 副次指標
  };
}

class BalanceExperimentManager {
  private activeExperiments: BalanceExperiment[] = [];
  
  getParameterValue(playerId: string, parameterName: string, defaultValue: number): number {
    const experiment = this.getActiveExperimentForPlayer(playerId, parameterName);
    
    if (!experiment) {
      return defaultValue;
    }
    
    const isInTreatmentGroup = this.isPlayerInTreatmentGroup(playerId, experiment.id);
    const parameter = experiment.parameters[parameterName];
    
    return isInTreatmentGroup ? parameter.treatment : parameter.control;
  }
  
  private isPlayerInTreatmentGroup(playerId: string, experimentId: string): boolean {
    // プレイヤーIDとexperimentIDをハッシュ化して一貫した振り分けを行う
    const hash = this.hashString(playerId + experimentId);
    return (hash % 100) < 50; // 50%で実験群に振り分け
  }
  
  private hashString(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // 32bit整数に変換
    }
    return Math.abs(hash);
  }
}
```

---

## 10. パフォーマンス最適化

### 10.1 計算キャッシュシステム

#### 重い計算のメモ化
```typescript
class GameCalculationCache {
  private cache = new Map<string, { value: any; timestamp: number; ttl: number }>();
  
  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;
    
    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return entry.value;
  }
  
  set<T>(key: string, value: T, ttlMs: number = 300000): void { // デフォルト5分
    this.cache.set(key, {
      value,
      timestamp: Date.now(),
      ttl: ttlMs
    });
  }
  
  // 複雑な計算のキャッシュ化
  getOrCalculate<T>(
    key: string,
    calculator: () => T,
    ttlMs: number = 300000
  ): T {
    const cached = this.get<T>(key);
    if (cached !== null) {
      return cached;
    }
    
    const result = calculator();
    this.set(key, result, ttlMs);
    return result;
  }
}

// 使用例
const calculationCache = new GameCalculationCache();

function getTrainerBattlePower(trainerId: string): number {
  const cacheKey = `trainer_battle_power_${trainerId}`;
  
  return calculationCache.getOrCalculate(cacheKey, () => {
    const trainer = getTrainerById(trainerId);
    return calculateTeamBattlePower({ pokemon: trainer.party, trainer });
  }, 60000); // 1分間キャッシュ
}
```

### 10.2 バッチ処理最適化

#### 大量派遣の効率処理
```typescript
function processBatchExpeditions(expeditions: Expedition[]): BatchProcessResult {
  // 並列処理可能な派遣をグループ化
  const expeditionGroups = groupExpeditionsByDependency(expeditions);
  
  const results: ExpeditionResult[] = [];
  
  for (const group of expeditionGroups) {
    // 同じグループ内は並列実行可能
    const groupResults = Promise.all(
      group.map(expedition => 
        processExpeditionOptimized(expedition)
      )
    );
    
    results.push(...await groupResults);
  }
  
  return {
    processedCount: expeditions.length,
    results,
    processingTime: Date.now() - startTime
  };
}

function processExpeditionOptimized(expedition: Expedition): Promise<ExpeditionResult> {
  // 軽量化されたシミュレーション
  const state = initializeExpeditionState(expedition);
  
  // 大きなタイムステップで効率的に処理
  const timeStepSize = Math.max(30, expedition.targetDurationHours * 60 / 20); // 最大20ステップ
  
  while (state.progress < 1.0) {
    state = simulateExpeditionStepOptimized(expedition, state, timeStepSize);
  }
  
  return Promise.resolve(finalizeExpeditionResult(expedition, state));
}
```

---

このゲームロジック仕様書は、企画書の要件を具体的なアルゴリズムと数式で実装可能な形に落とし込んでいます。各システムは独立してテスト可能で、バランス調整も容易な設計となっています。